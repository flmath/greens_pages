(window.webpackJsonp=window.webpackJsonp||[]).push([[16,17],{52:function(t,e,n){"use strict";n.r(e);var a=n(11),r=n(12),i=n(14),c=n(13),o=n(15),s=n(0),l=n.n(s),u=n(438),_=n(54),m=function(t){function e(){return Object(a.a)(this,e),Object(i.a)(this,Object(c.a)(e).apply(this,arguments))}return Object(o.a)(e,t),Object(r.a)(e,[{key:"render",value:function(){var t=this.props,e=t.language,n=t.value;return l.a.createElement(u.a,{language:e,style:_.coy},n)}}]),e}(s.PureComponent);m.defaultProps={language:null},e.default=m},65:function(t,e,n){"use strict";n.r(e),n.d(e,"default",function(){return s});var a=n(0),r=n.n(a),i=n(53),c=n.n(i),o=n(52);function s(t){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(c.a,{source:"Tracing all functions in a module is sometimes too much for printout readability.\nFortunately, it is easy to narrow tracing to a specific function. Lets trace `traced_function/2`. First, let us use `dbg:tp`\n```erlang\n > dbg:tp({tracing_experiments, traced_function, 2},[]),\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 49\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nSince `traced_function/2` is local we do not get any additional traces. Lets add local tracing.\n```erlang\n > dbg:tpl({tracing_experiments, traced_function, 2},[]),\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_light_state number 108\n (<0.134.0>) call tracing_experiments:traced_function(enter_light_state,108)\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nIt works fine, lets extract a little more information, \nthe second argument in `dbg:tp/2` can take a form of `[{ MatchHead, MatchConditions, MatchBody }]`.\nMatchHead can be `'_'` for anonymous variables or we can match it to the variable `'$1'` to display it later.\n```erlang\n > dbg:tpl({tracing_experiments, traced_function, 2},[{'$1', [], [{display, '$1'}]}]),\n > tracing_experiments:switch_state().\n [enter_light_state,228]\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_light_state number 228\n (<0.134.0>) call tracing_experiments:traced_function(enter_light_state,228)\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nSo the function is called with parameters enter_light_state and 228.\nLets return in body two more pieces of information.\nThe first what values is returned from the function:\n```erlang\n > dbg:tpl({tracing_experiments, traced_function, 2},[{'_', [], [ {return_trace}]}]),\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 5\n (<0.134.0>) call tracing_experiments:traced_function(enter_heavy_state,5)\n (<0.134.0>) returned from tracing_experiments:traced_function/2 -> ok\n ok\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nIt returns an `ok` atom from debug printing function. \nIt is worth mentioning that according to documentation `{return_trace}` can\ninterfere with the system behavior.\nIf you want also the `'EXIT'` messages to be displayed you can replace `{return_trace}` with `{exception_trace}` instead.\n\nReference: [Erlang documentation: functions allowed only for tracing.](http://erlang.org/doc/apps/erts/match_spec.html#functions-allowed-only-for-tracing)\n",renderers:{code:o.default}}))}}}]);
//# sourceMappingURL=16.55925de8.chunk.js.map
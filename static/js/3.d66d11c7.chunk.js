(window.webpackJsonp=window.webpackJsonp||[]).push([[3,6,7,8,9,10,11,12,13,14,15,16,17,18],{52:function(e,t,n){"use strict";n.r(t);var a=n(11),r=n(12),s=n(14),i=n(13),o=n(15),c=n(0),l=n.n(c),u=n(438),m=n(54),d=function(e){function t(){return Object(a.a)(this,t),Object(s.a)(this,Object(i.a)(t).apply(this,arguments))}return Object(o.a)(t,e),Object(r.a)(t,[{key:"render",value:function(){var e=this.props,t=e.language,n=e.value;return l.a.createElement(u.a,{language:t,style:m.coy},n)}}]),t}(c.PureComponent);d.defaultProps={language:null},t.default=d},58:function(e,t){e.exports=function(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}},61:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return s});var a=n(0),r=n.n(a);function s(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement("p",null,"An important aspect of the Erlang/OTP platforms maturity is the presence of native debug library. Unfortunately, the dbg module is not only steep to learn but also can be very harmful if misused (see ",r.a.createElement("a",{href:"#CustomHandler"},"Custom Handler: Introduction"),"). In this post, I show how to use the tool, avoid pitfalls and extract the needed information. The article is composed of scenarios starting with the most basic and then expanding it with the usage of the module different caveats. Each scenario uses very simple gen_statem as target practice, the setup of it is in the following chapter."))}},62:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"The tracing_experiments application is very simple gen_statem written specifically to test debugging facilities.\nYou can find it on [my GitHub repo](https://github.com/flmath/tracing_experiments). All experiments are run in a shell started with:\n\n```bash\n$ local_rebar/rebar3 as dbg shell\n``` \n\nfor a clear view.",renderers:{code:o.default}}))}},64:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return l});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52),c="Let us start with a basic scenario. I will omit some of the messages printed out by the shell for clarity.\n```erlang\n > dbg:tracer(). \n {ok,<0.218.0>}\n```\n```erlang\n > dbg:p(all,[c]).\n {ok,[{matched,nonode@nohost,71}]}\n```\n```erlang\n > dbg:tp(tracing_experiments, []).\n (<0.117.0>) call tracing_experiments:module_info()\n {ok,[{matched,nonode@nohost,13}]}\n```\nNow lets switch traced process to more busy state:\n```erlang\n > tracing_experiments:switch_state().\n```\nWe get messages in a loop:\n```erlang\n tracing_experiments.erl:86:<0.134.0>: io:format called from state keep_heavy_state number 8\n (<0.134.0>) call tracing_experiments:heavy_state(timeout,1000,#{iterator => 8})\n ...\n```\nLets switch back:\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nThe first message comes from debug function we have put into the code.\nThe second is actually printed out by our `dbg:tracer/0`\nBut if you look into the code, there is another `traced_function/2` that is present in the\ntracing_experiments module that is not printed out. It is because `dbg:tp/2` prints only the exported functions.\nFor local functions we need also to run:\n```erlang\n > dbg:tpl(tracing_experiments, []).\n (<0.117.0>) call tracing_experiments:module_info()\n {ok,[{matched,nonode@nohost,14}]}\n```\nLet us see how it works:\n```erlang\n > tracing_experiments:switch_state().\n (<0.117.0>) call tracing_experiments:switch_state()\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 26\n (<0.134.0>) call tracing_experiments:light_state(cast,switch_state,#{iterator => 26})\n (<0.134.0>) call tracing_experiments:traced_function(enter_heavy_state,26)\n ok\n```\n```erlang\n > tracing_experiments:switch_state()\n ok \n```\nSo we can see additional printout for `traced_function/2`.\nWhich concludes the most basic scenario.\nLet clean our tracing setup.\n```erlang\n > dbg:ctp('_').\n ok\n```\nLets double check it.\n```erlang\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_light_state number 39\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nThe call tracing is set off.\n";function l(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:c,renderers:{code:o.default}}))}},65:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"Tracing all functions in a module is sometimes too much for printout readability.\nFortunately, it is easy to narrow tracing to a specific function. Lets trace `traced_function/2`. First, let us use `dbg:tp`\n```erlang\n > dbg:tp({tracing_experiments, traced_function, 2},[]),\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 49\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nSince `traced_function/2` is local we do not get any additional traces. Lets add local tracing.\n```erlang\n > dbg:tpl({tracing_experiments, traced_function, 2},[]),\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_light_state number 108\n (<0.134.0>) call tracing_experiments:traced_function(enter_light_state,108)\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nIt works fine, lets extract a little more information, \nthe second argument in `dbg:tp/2` can take a form of `[{ MatchHead, MatchConditions, MatchBody }]`.\nMatchHead can be `'_'` for anonymous variables or we can match it to the variable `'$1'` to display it later.\n```erlang\n > dbg:tpl({tracing_experiments, traced_function, 2},[{'$1', [], [{display, '$1'}]}]),\n > tracing_experiments:switch_state().\n [enter_light_state,228]\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_light_state number 228\n (<0.134.0>) call tracing_experiments:traced_function(enter_light_state,228)\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nSo the function is called with parameters enter_light_state and 228.\nLets return in body two more pieces of information.\nThe first what values is returned from the function:\n```erlang\n > dbg:tpl({tracing_experiments, traced_function, 2},[{'_', [], [ {return_trace}]}]),\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 5\n (<0.134.0>) call tracing_experiments:traced_function(enter_heavy_state,5)\n (<0.134.0>) returned from tracing_experiments:traced_function/2 -> ok\n ok\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\nIt returns an `ok` atom from debug printing function. \nIt is worth mentioning that according to documentation `{return_trace}` can\ninterfere with the system behavior.\nIf you want also the `'EXIT'` messages to be displayed you can replace `{return_trace}` with `{exception_trace}` instead.\n\nReference: [Erlang documentation: functions allowed only for tracing.](http://erlang.org/doc/apps/erts/match_spec.html#functions-allowed-only-for-tracing)\n",renderers:{code:o.default}}))}},66:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"Another information we could want to retrieve is the function that triggered our traced function.\n```erlang\n > dbg:tpl({tracing_experiments, traced_function, 2},\n    [{'_', [], [ {message,{caller}}]}]).\n {ok,[{matched,nonode@nohost,1},{saved,4}]} \n```\n\n```erlang\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 13 \n (<0.134.0>) call tracing_experiments:traced_function(enter_heavy_state,13)  \n   ({tracing_experiments, light_state, 3})\n ok\n```\n\n```erlang\n > tracing_experiments:switch_state().\n```\n",renderers:{code:o.default}}))}},67:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"Let us retrieve timestamps of entering and leaving the function.\nTo get them to need to add another two flags in `dbg:p/2`, the `strict_monotonic_timestamp`, and `return_to`\n```erlang\n > dbg:p(all,[call, strict_monotonic_timestamp, return_to]),\n > dbg:tpl({tracing_experiments, traced_function, 2},\n    [{'$1', [], [{display, '$1'}, {return_trace}]}]).\n```\n\n```erlang\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 91\n (<0.134.0>) call tracing_experiments:traced_function(enter_heavy_state,91)\n    ({tracing_experiments, light_state, 3})\n (Timestamp: {-576091093700236178, -576460752303423401})\n\n (<0.134.0>) returning to tracing_experiments:light_state/3 \n    (Timestamp: {-576091093699220788, -576460752303423400})\n ok\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok\n```\n\n```erlang\n TimeDiff = 576091093700236178-576091093699220788.\n 1015390\n erlang:convert_time_unit(TimeDiff, native, millisecond).\n 1\n```\nSo, we spent one millisecond in `traced_function/2`.\n",renderers:{code:o.default}}))}},68:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"The problem with all of the commands above is, that all the messages are printed out to the shell. What in case of tracing very active function ends up blocking the shell by spamming it with a continuous unreadable amount of printouts.\nThe classic example provided on https://massemanet.github.io/eper/redbug\nis: \n(CAUTION: it will hang the shell, run it in separate only to see how it looks like).\n```erlang\n > dbg:tracer(),dbg:p(all,[m]).\n {ok,[{matched,nonode@nohost,71}]}\n```\nTo deal with that we need to customize the way we are reading our messages. \nInstead of the `dbg:trace/0` we use the `dbg:trace/2` which takes as first argument an atom. Possible values are:\nport - the trace messages are sent to port\nprocess - we handle trace messages with custom function\nmodule - we implement trace module\nSince we consider here scenario with limited options (otherwise it is just better to install one of the mentioned frameworks), we will use the process case. In that scenario, the second argument of the `dbg:trace/2` has a form of a tuple: `{Fun, InitData}`. The Fun is a function that takes two arguments. The first is the received message and the second is the accumulator returned from the previous iteration. The `InitData` is a starting value of the accumulator. In other words, it works like `lists:foldl/3` with the difference that instead input list we process received trace messages.\nLet us start with a Fun that will assure that dbg will stop after receiving exactly one message, eliminating the possibility that we hang the shell by flooding it with a continuous stream of messages.\n\n```erlang\n > Fun = fun(X, Acc) ->\n > io:format(\"Value X:~p Value Acc: ~p~n\", [X,Acc]), \n > dbg:stop(),\n > [X|Acc]\n > end.\n #Fun<erl_eval.12.128620087> \n```\n\n```erlang\n > dbg:ctp('_').\n {ok,[]} \n```\n\n```erlang\n > dbg:tracer(process,{Fun,[]}),\n > dbg:p(all,[c]),\n > dbg:tpl({tracing_experiments, traced_function, 2},[{'_', [], []}]).\n {ok,[{matched,nonode@nohost,1},{saved,1}]} \n```\n\n```erlang\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 56\n Value X:{trace,<0.134.0>,call,\n {tracing_experiments,traced_function,[enter_heavy_state,56]}} Value Acc: [] \n ok \n\n > tracing_experiments.erl:86:<0.134.0>: io:format called from state keep_heavy_state number 57 \n\n > tracing_experiments.erl:86:<0.134.0>: io:format called from state keep_heavy_state number 58 \n ...\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok \n```\nFrom hard-coded debug messages, you can see that `traced_function/2` is called continuously, but only the traces for state 56 are printed out. So we have a working safe switch.\nLets see what will happened if we go for classical example:\n```erlang\n > dbg:tracer(process,{Fun,[]}). {ok,<0.655.0>}\n > dbg:p(all,[m]). \n ... long but finite output ...\n```\nThe shell is operational.\n",renderers:{code:o.default}}))}},69:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"Now we can customize our processing function.\nLet it print the first 2 messages that state number is multiplication of 5:\nFor clarity lets define trace record in our shell\n```erlang\n > rd(trace, {pid, type, mfa}).\n```\n\n```erlang\n Fun25 = fun\n  (X, 2) ->\n  dbg:stop();\n  (#trace{type=call,mfa={_,_,[keep_heavy_state, X]}}, Acc)\n  when 0==(X rem 5) ->\n  io:format(\"Value X:~p Value Acc: ~p~n\", [X,Acc]),\n  Acc+1;\n (_, Acc) -> Acc\n end.\n #Fun<erl_eval.12.128620087> \n```\n\n```erlang\n > dbg:tracer(process,{Fun25,0}),\n > dbg:p(all,[c]),\n > dbg:tpl({tracing_experiments, traced_function, 2},[{'_', [], []}]).\n```\n\n```erlang\ntracing_experiments:switch_state().\n...\ntracing_experiments:switch_state().\n```\nNow we know how to add pattern matching to our not-blocking-shell solution.\n",renderers:{code:o.default}}))}},70:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:'One thing extra we should learn is catching exit and error messages.\nWe can use the Fun function to see how those messages look like:\n```erlang\n FunExit = fun\n  (#trace{type=exit,mfa=Reason}, MsgNo)->\n  io:format("Value: ~p Value MsgNo: ~p~n", [{exit, Reason}, MsgNo]),\n  dbg:stop();\n (_, MsgNo) -> MsgNo\n end.\n```\n\n```erlang\n > dbg:tracer(process,{FunExit,0}).\n```\n Lets trace process events, aside of calls.\n\n```erlang\n > dbg:p(all,[p,c]).\n```\n\n And invoke termination with one of the below functions:\n```erlang\n gen_statem:cast({global, tracing_experiments}, wrong_cast).\n exit(global:whereis_name(tracing_experiments), "something").\n exit(global:whereis_name(tracing_experiments), kill).\n exit(global:whereis_name(tracing_experiments), normal).\n ...\n```\nOf course, when we are dealing with local processes we should replace \nthe `global:whereis_name(ProcessName)` with the `whereis(ProcessName)`.',renderers:{code:o.default}}))}},71:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"If the system consists of many OTP processes that are handled \nwith special messages and the process we are interested in \nis registered it is worth to narrow our search by tracing specific process.\n```erlang\n > dbg:tracer(process,{Fun,[]}),\n > Pid = global:whereis_name(tracing_experiments).\n <0.134.0>\n```\n\n```erlang\n > dbg:p(global:whereis_name(tracing_experiments), [c,p]).\n {ok,[{matched,nonode@nohost,1}]}\n```\n",renderers:{code:o.default}}))}},72:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"Let us purge the tracing from the system.\nFirst, clean up the process flags.\n```erlang\n > dbg:p(all,clear).\n```\nRemove function tracing.\n```erlang\n > dbg:ctp('_').\n```\nShutdown the debug tracer.\n```erlang\n > dbg:stop().\n```\n",renderers:{code:o.default}}))}},73:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),r=n.n(a),s=n(53),i=n.n(s),o=n(52);function c(e){return r.a.createElement("div",{className:"my_md_container"},r.a.createElement(i.a,{source:"* First, try to check other sources of information, in most cases, the erlang dump file should be enough.\n\n* If it is possible to install some debug/test framework instead, for example:\n\n- https://massemanet.github.io/eper/redbug\n\n- https://ferd.github.io/recon/\n\n* If you are a consultant check your insurance.\n\n* Since the `return_trace` (and `exception_trace`) flag is potentially behavior-changing we'd better avoid it.\n\n* I have omitted `seq_trace` utilities, on purpose, I do not feel well when a single press of the tab key can hang your shell. But if you are comfortable with sequence tracing on production nodes, then why have you read through this document in the first place?\n\n* If you still see need to use dbg on live node start from writing \na processing function that has message counter as an accumulator and safeguards to `dbg:stop/0` after a specific number of printed messages.\n\n* It is good when the number of messages is safeguarded in the first header of the defined function (see [`Fun25`](#CustomHandlerMessageFilter)).\n\n* Alternatively just run `dbg:stop/0` after the first match if you don't need to catch more than one message.\nYou can mail me: flmathematic at gmail.com.",renderers:{code:o.default}}))}},74:function(e,t,n){"use strict";n.d(t,"a",function(){return o}),n.d(t,"b",function(){return c});var a=n(0),r=n.n(a),s=n(77),i=n(78);function o(e){return r.a.createElement("div",{className:"my_cv_header_container"},r.a.createElement(s.a,{className:"my_cv_header_container_row"},r.a.createElement(i.a,null,r.a.createElement("hr",{className:"my_cv_header"}),r.a.createElement("h2",{className:"my_cv_header"}," ",e.children," "),r.a.createElement("hr",{className:"my_cv_header"}))))}function c(e){return r.a.createElement("div",{className:"my_cv_header_container"},r.a.createElement("br",null),r.a.createElement(s.a,{className:"my_cv_header_container_row"},r.a.createElement(i.a,null,r.a.createElement("h2",{className:"my_cv_header"}," ",e.children," "))))}},77:function(e,t,n){"use strict";var a=n(2),r=n(4),s=n(0),i=n.n(s),o=n(1),c=n.n(o),l=n(8),u=n.n(l),m=n(3),d={tag:m.b,noGutters:c.a.bool,className:c.a.string,cssModule:c.a.object,form:c.a.bool},g=function(e){var t=e.className,n=e.cssModule,s=e.noGutters,o=e.tag,c=e.form,l=Object(r.a)(e,["className","cssModule","noGutters","tag","form"]),d=Object(m.a)(u()(t,s?"no-gutters":null,c?"form-row":"row"),n);return i.a.createElement(o,Object(a.a)({},l,{className:d}))};g.propTypes=d,g.defaultProps={tag:"div"},t.a=g},78:function(e,t,n){"use strict";var a=n(2),r=n(4),s=n(58),i=n.n(s),o=n(0),c=n.n(o),l=n(1),u=n.n(l),m=n(8),d=n.n(m),g=n(3),h=u.a.oneOfType([u.a.number,u.a.string]),f=u.a.oneOfType([u.a.bool,u.a.number,u.a.string,u.a.shape({size:u.a.oneOfType([u.a.bool,u.a.number,u.a.string]),order:h,offset:h})]),p={tag:g.b,xs:f,sm:f,md:f,lg:f,xl:f,className:u.a.string,cssModule:u.a.object,widths:u.a.array},_={tag:"div",widths:["xs","sm","md","lg","xl"]},b=function(e,t,n){return!0===n||""===n?e?"col":"col-"+t:"auto"===n?e?"col-auto":"col-"+t+"-auto":e?"col-"+n:"col-"+t+"-"+n},w=function(e){var t=e.className,n=e.cssModule,s=e.widths,o=e.tag,l=Object(r.a)(e,["className","cssModule","widths","tag"]),u=[];s.forEach(function(t,a){var r=e[t];if(delete l[t],r||""===r){var s=!a;if(i()(r)){var o,c=s?"-":"-"+t+"-",m=b(s,t,r.size);u.push(Object(g.a)(d()(((o={})[m]=r.size||""===r.size,o["order"+c+r.order]=r.order||0===r.order,o["offset"+c+r.offset]=r.offset||0===r.offset,o)),n))}else{var h=b(s,t,r);u.push(h)}}}),u.length||u.push("col");var m=Object(g.a)(d()(t,u),n);return c.a.createElement(o,Object(a.a)({},l,{className:m}))};w.propTypes=p,w.defaultProps=_,t.a=w},85:function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),s=n(74),i=n(61),o=n(62),c=n(64),l=n(65),u=n(66),m=n(67),d=n(68),g=n(69),h=n(70),f=n(71),p=n(72),_=n(73);t.default=function(e){return r.a.createElement("div",{id:"cvmainbody"},r.a.createElement("section",{id:"Introduction"},r.a.createElement(s.b,null,"Introduction"),r.a.createElement(i.default,null)),r.a.createElement("section",{id:"Setup"},r.a.createElement(s.b,null,"Setup"),r.a.createElement(o.default,null)),r.a.createElement("section",{id:"BasicScenario"},r.a.createElement(s.b,null,"Basic Scenario"),r.a.createElement(c.default,null)),r.a.createElement("section",{id:"TraceFunction"},r.a.createElement(s.b,null,"Trace Function"),r.a.createElement(l.default,null)),r.a.createElement("section",{id:"FindCaller"},r.a.createElement(s.b,null,"Function Caller Finding"),r.a.createElement(u.default,null)),r.a.createElement("section",{id:"Timestamps"},r.a.createElement(s.b,null,"Timestamps"),r.a.createElement(m.default,null)),r.a.createElement("section",{id:"CustomHandler"},r.a.createElement(s.b,null,"Custom Handler: Introduction"),r.a.createElement(d.default,null)),r.a.createElement("section",{id:"CustomHandlerMessageFilter"},r.a.createElement(s.b,null,"Custom Handler: Message Filter"),r.a.createElement(g.default,null)),r.a.createElement("section",{id:"CustomHandlerSignals"},r.a.createElement(s.b,null,"Custom Handler: Signals"),r.a.createElement(h.default,null)),r.a.createElement("section",{id:"RegisteredProcessesTracking"},r.a.createElement(s.b,null,"Registered Process Tracking"),r.a.createElement(f.default,null)),r.a.createElement("section",{id:"Cleanup"},r.a.createElement(s.b,null,"Cleanup"),r.a.createElement(p.default,null)),r.a.createElement("section",{id:"Conclusion"},r.a.createElement(s.b,null,"Conclusion"),r.a.createElement(_.default,null)),r.a.createElement("div",{className:"empty_scroll"},r.a.createElement("br",null)))}}}]);
//# sourceMappingURL=3.d66d11c7.chunk.js.map
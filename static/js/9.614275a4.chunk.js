(window.webpackJsonp=window.webpackJsonp||[]).push([[9,17],{52:function(e,t,n){"use strict";n.r(t);var a=n(11),s=n(12),r=n(14),o=n(13),i=n(15),c=n(0),l=n.n(c),u=n(438),h=n(54),d=function(e){function t(){return Object(a.a)(this,t),Object(r.a)(this,Object(o.a)(t).apply(this,arguments))}return Object(i.a)(t,e),Object(s.a)(t,[{key:"render",value:function(){var e=this.props,t=e.language,n=e.value;return l.a.createElement(u.a,{language:t,style:h.coy},n)}}]),t}(c.PureComponent);d.defaultProps={language:null},t.default=d},68:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return c});var a=n(0),s=n.n(a),r=n(53),o=n.n(r),i=n(52);function c(e){return s.a.createElement("div",{className:"my_md_container"},s.a.createElement(o.a,{source:"The problem with all of the commands above is, that all the messages are printed out to the shell. What in case of tracing very active function ends up blocking the shell by spamming it with a continuous unreadable amount of printouts.\nThe classic example provided on https://massemanet.github.io/eper/redbug\nis: \n(CAUTION: it will hang the shell, run it in separate only to see how it looks like).\n```erlang\n > dbg:tracer(),dbg:p(all,[m]).\n {ok,[{matched,nonode@nohost,71}]}\n```\nTo deal with that we need to customize the way we are reading our messages. \nInstead of the `dbg:trace/0` we use the `dbg:trace/2` which takes as first argument an atom. Possible values are:\nport - the trace messages are sent to port\nprocess - we handle trace messages with custom function\nmodule - we implement trace module\nSince we consider here scenario with limited options (otherwise it is just better to install one of the mentioned frameworks), we will use the process case. In that scenario, the second argument of the `dbg:trace/2` has a form of a tuple: `{Fun, InitData}`. The Fun is a function that takes two arguments. The first is the received message and the second is the accumulator returned from the previous iteration. The `InitData` is a starting value of the accumulator. In other words, it works like `lists:foldl/3` with the difference that instead input list we process received trace messages.\nLet us start with a Fun that will assure that dbg will stop after receiving exactly one message, eliminating the possibility that we hang the shell by flooding it with a continuous stream of messages.\n\n```erlang\n > Fun = fun(X, Acc) ->\n > io:format(\"Value X:~p Value Acc: ~p~n\", [X,Acc]), \n > dbg:stop(),\n > [X|Acc]\n > end.\n #Fun<erl_eval.12.128620087> \n```\n\n```erlang\n > dbg:ctp('_').\n {ok,[]} \n```\n\n```erlang\n > dbg:tracer(process,{Fun,[]}),\n > dbg:p(all,[c]),\n > dbg:tpl({tracing_experiments, traced_function, 2},[{'_', [], []}]).\n {ok,[{matched,nonode@nohost,1},{saved,1}]} \n```\n\n```erlang\n > tracing_experiments:switch_state().\n tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 56\n Value X:{trace,<0.134.0>,call,\n {tracing_experiments,traced_function,[enter_heavy_state,56]}} Value Acc: [] \n ok \n\n > tracing_experiments.erl:86:<0.134.0>: io:format called from state keep_heavy_state number 57 \n\n > tracing_experiments.erl:86:<0.134.0>: io:format called from state keep_heavy_state number 58 \n ...\n```\n\n```erlang\n > tracing_experiments:switch_state().\n ok \n```\nFrom hard-coded debug messages, you can see that `traced_function/2` is called continuously, but only the traces for state 56 are printed out. So we have a working safe switch.\nLets see what will happened if we go for classical example:\n```erlang\n > dbg:tracer(process,{Fun,[]}). {ok,<0.655.0>}\n > dbg:p(all,[m]). \n ... long but finite output ...\n```\nThe shell is operational.\n",renderers:{code:i.default}}))}}}]);
//# sourceMappingURL=9.614275a4.chunk.js.map
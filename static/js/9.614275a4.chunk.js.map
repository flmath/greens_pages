{"version":3,"sources":["private_pages/ErlangDBG/CodeBlock.js","private_pages/ErlangDBG/sections/CustomHandler.js"],"names":["CodeBlock","_this$props","this","props","language","value","react__WEBPACK_IMPORTED_MODULE_5___default","a","createElement","react_syntax_highlighter__WEBPACK_IMPORTED_MODULE_6__","style","coy","PureComponent","defaultProps","__webpack_require__","r","__webpack_exports__","d","CustomHandler","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","react_markdown__WEBPACK_IMPORTED_MODULE_1__","react_markdown__WEBPACK_IMPORTED_MODULE_1___default","_CodeBlock__WEBPACK_IMPORTED_MODULE_2__","className","source","renderers","code"],"mappings":"gLAKMA,mLAUK,IAAAC,EACqBC,KAAKC,MAAzBC,EADDH,EACCG,SAAUC,EADXJ,EACWI,MAClB,OACEC,EAAAC,EAAAC,cAACC,EAAA,EAAD,CAAmBL,SAAUA,EAAUM,MAAOC,OAC3CN,UAdeO,iBAAlBZ,EAMGa,aAAe,CACpBT,SAAU,MAaCJ,6CCzBfc,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,4BAAAE,IAAA,IAAAC,EAAAL,EAAA,GAAAM,EAAAN,EAAAO,EAAAF,GAAAG,EAAAR,EAAA,IAAAS,EAAAT,EAAAO,EAAAC,GAAAE,EAAAV,EAAA,IAIe,SAASI,EAAcf,GAgFpC,OACEiB,EAAAb,EAAAC,cAAA,OAAKiB,UAAU,mBACdL,EAAAb,EAAAC,cAACe,EAAAhB,EAAD,CAAemB,OA9EpB,q4FA8EmCC,UAAW,CAAEC,KAAM5B","file":"static/js/9.614275a4.chunk.js","sourcesContent":["import React, { PureComponent } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { coy } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\n\nclass CodeBlock extends PureComponent {\n  static propTypes = {\n    value: PropTypes.string.isRequired,\n    language: PropTypes.string\n  };\n\n  static defaultProps = {\n    language: null\n  };\n\n  render() {\n    const { language, value } = this.props;\n    return (\n      <SyntaxHighlighter language={language} style={coy}>\n        {value}\n      </SyntaxHighlighter>\n    );\n  }\n}\n\nexport default CodeBlock;\n","import React from \"react\";\nimport ReactMarkdown from 'react-markdown';\nimport CodeBlock from \"../CodeBlock\";\n\nexport default function CustomHandler(props) {\n\nconst input =\n\n'The problem with all of the commands above is, '+\n'that all the messages are printed out to the shell. What '+\n'in case of tracing very active function ends up blocking the shell by spamming it with a continuous unreadable amount of printouts.\\n'+\n\n'The classic example provided on https://massemanet.github.io/eper/redbug\\n'+\n'is: \\n'+\n'(CAUTION: it will hang the shell, run it in separate only to see how it looks like).\\n'+\n'```erlang\\n'+\n' > dbg:tracer(),dbg:p(all,[m]).\\n'+\n' {ok,[{matched,nonode@nohost,71}]}\\n'+\n'```\\n'+\n'To deal with that we need to customize the way we are reading our messages. \\n'+\n'Instead of the `dbg:trace/0` we use the `dbg:trace/2` which takes as first argument an atom. Possible values are:\\n'+\n'port - the trace messages are sent to port\\n'+\n'process - we handle trace messages with custom function\\n'+\n'module - we implement trace module\\n'+\n\n'Since we consider here scenario with limited options '+\n'(otherwise it is just better to install one of the mentioned frameworks), we will use the process case. '+\n'In that scenario, the second argument of the `dbg:trace/2` has a form of a tuple: `{Fun, InitData}`. '+\n'The Fun is a function that takes two arguments. '+\n'The first is the received message and the second is the accumulator returned from the previous iteration. '+\n'The `InitData` is a starting value of the accumulator. '+\n'In other words, it works like `lists:foldl/3` with the difference that instead input list we process received trace messages.\\n'+\n\n'Let us start with a Fun that will assure that dbg will stop after receiving exactly one message, '+\n'eliminating the possibility that we hang the shell by flooding it with a continuous stream of messages.\\n'+\n'\\n'+\n'```erlang\\n'+\n' > Fun = fun(X, Acc) ->\\n'+\n' > io:format(\"Value X:~p Value Acc: ~p~n\", [X,Acc]), \\n'+\n' > dbg:stop(),\\n'+\n' > [X|Acc]\\n'+\n' > end.\\n'+\n' #Fun<erl_eval.12.128620087> \\n'+\n'```\\n'+\n'\\n'+\n'```erlang\\n'+\n' > dbg:ctp(\\'_\\').\\n'+\n' {ok,[]} \\n'+\n'```\\n'+\n'\\n'+\n'```erlang\\n'+\n' > dbg:tracer(process,{Fun,[]}),\\n'+\n' > dbg:p(all,[c]),\\n'+\n' > dbg:tpl({tracing_experiments, traced_function, 2},[{\\'_\\', [], []}]).\\n'+\n' {ok,[{matched,nonode@nohost,1},{saved,1}]} \\n'+\n'```\\n'+\n'\\n'+\n'```erlang\\n'+\n' > tracing_experiments:switch_state().\\n'+                      \n' tracing_experiments.erl:86:<0.134.0>: io:format called from state enter_heavy_state number 56\\n'+\n' Value X:{trace,<0.134.0>,call,\\n'+\n' {tracing_experiments,traced_function,[enter_heavy_state,56]}} Value Acc: [] \\n'+\n' ok \\n'+\n'\\n'+\n' > tracing_experiments.erl:86:<0.134.0>: io:format called from state keep_heavy_state number 57 \\n'+\n'\\n'+\n' > tracing_experiments.erl:86:<0.134.0>: io:format called from state keep_heavy_state number 58 \\n'+\n' ...\\n'+\n'```\\n'+\n'\\n'+\n'```erlang\\n'+\n' > tracing_experiments:switch_state().\\n'+\n' ok \\n'+\n'```\\n'+\n'From hard-coded debug messages, you can see that `traced_function/2` is called continuously, '+\n'but only the traces for state 56 are printed out. So we have a working safe switch.\\n'+\n'Lets see what will happened if we go for classical example:\\n'+\n'```erlang\\n'+\n' > dbg:tracer(process,{Fun,[]}). {ok,<0.655.0>}\\n'+\n' > dbg:p(all,[m]). \\n'+\n' ... long but finite output ...\\n'+\n'```\\n'+\n'The shell is operational.\\n'\n\n  return (\n    <div className=\"my_md_container\">\n     <ReactMarkdown source={input} renderers={{ code: CodeBlock }}/>\n    </div>\n  );\n}\n"],"sourceRoot":""}